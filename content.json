{"meta":{"title":"晓小小小码农","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Vuex","slug":"Vuex","date":"2019-03-01T14:25:30.000Z","updated":"2019-06-12T15:45:19.197Z","comments":true,"path":"2019/03/01/Vuex/","link":"","permalink":"http://yoursite.com/2019/03/01/Vuex/","excerpt":"重新认真走一遍来时的路，又是另一种认识Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。通俗讲就是组件之间数据共享，代码维护和少敲几遍且稍稍看似不影响性能的代码12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)","text":"重新认真走一遍来时的路，又是另一种认识Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。通俗讲就是组件之间数据共享，代码维护和少敲几遍且稍稍看似不影响性能的代码12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) Vuex中主要包括的State、Getter、Mutaion、Action和Module，前四者用的比较多。通过字面意思大致为State状态（数据源），Getter获取数据，Mutaion直接修改数据，Action异步修改数据，Module模块化。 State12345678const content = &#123; template:`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed:&#123; count()&#123; return store.state.count &#125; &#125;&#125; 这里看着是一个计算属性取state对象的属性，但是一旦多了就会像这样了。1234567891011121314151617const content = &#123; template:`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed:&#123; count()&#123; return store.state.count &#125;, count1()&#123; return store.state.count1 &#125;, count2()&#123; return store.state.count2 &#125;, count3()&#123; return store.state.coun3 &#125; &#125;&#125; 这样看着实在确实有种代码没有复用的问题,在通过Vuex文档会发现，官方在这些上分别给我们提供了辅助函数（四个）;在辅助函数的基础上去做这些操作就会发现简单快捷了很多，大大的提高了开发效率;例如上面代码没有使用辅助函数带来的问题使用后会是这样的： 1234567891011121314151617import &#123; mapState &#125; from &apos;vuex&apos;const content = &#123; template:`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed:mapSate(&#123; count:state =&gt; state.count, &#125;); //第一种 computed:mapState([&apos;count&apos;]);//第二种 // 映射 this.count 为 store.state.count &#125; // 或者可以使用 ... ES6的展开运算符 computed:&#123; count()&#123; return store.state.count &#125;, ...mapState([&apos;count1&apos;]) &#125;&#125; Getter类似于计算属性，我们需要从state中获取某个值，但是需要经过处理后获得的值这个时候我们需要Getter来进行操作了，getter的返回值会根据依赖缓存起来，且且只有当它的依赖值发生了改变才会被重新计算。12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) mapGetters 辅助函数12345678910111213//mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &apos;doneTodos&apos; ]) &#125;&#125; Mutation在Vuex中改变State中的状态的唯一方式提交mutation，也就是更新值的唯一方式。12345678910111213141516171819202122232425262728293031323334353637const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; // state整个对象 // state：第一个参数, payload(载荷):第二个参数建议用对象的方式传进来,大多数的时候也是对象 increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;)// 触发store.commit(&apos;increment&apos;) //默认-1//带有第二个参数store.commit(&apos;increment&apos;,10) // 2store.commit(&apos;increment&apos;,&#123; // 3 amount:10&#125;)// 建议通常如下写法//type 属性的对象的写法store.commit(&#123; //4 type:&apos;increment&apos;, amount: 10&#125;)//拥有参数的提交时，mutations中也要接受参数//这样适用3或者4的提交方式mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; *Mutation 必须是同步函数，Action中是提交mutations，然后在去更改的状态，这样可以包含任意的异步操作mapMutations辅助函数12345678910111213import &#123; mapMutations &#125; from &apos;vuex&apos;export default &#123; // ... methods: &#123; ...mapMutations([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)` ]), ...mapMutations(&#123; add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)` &#125;) &#125;&#125; Action如果在mutations之前有异步操作的时候就可以借助Action来先执行了异步在提交mutations123456789101112131415161718192021const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; // 第一种写法 increment (context) &#123; // context 类似store实例相同的方法和属性，因此可以调用commit context.commit(&apos;increment&apos;) &#125; //第二种 es6的参数解构方式来简化代码 increment (&#123;commit&#125;) &#123; commit(&apos;increment&apos;) &#125; &#125;&#125;) mutations中只能同步，action异步操作1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&apos;increment&apos;) &#125;, 1000) &#125;&#125; 在Action中常用的分发，dispatch()。同样支持载荷方式进行分发12345678910111213// 以载荷形式分发store.dispatch(&apos;incrementAsync&apos;, &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: &apos;incrementAsync&apos;, amount: 10&#125;)//通常建议用对象的形式分发//action异步完成时返回promise对象 *mapAction辅助函数跟mapMutations类似 记录下来，更多有助于自己去总结和技术提升之后的优化代码","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"递归","slug":"递归","date":"2019-02-23T14:52:30.000Z","updated":"2019-06-02T15:10:36.227Z","comments":true,"path":"2019/02/23/递归/","link":"","permalink":"http://yoursite.com/2019/02/23/递归/","excerpt":"设置当前递归函数为null时出现的错误，拿小本本记录上递归函数是在一个函数通过名字调用自身的情况下构成1234567function recursion(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * recursion(num - 1); &#125;&#125;","text":"设置当前递归函数为null时出现的错误，拿小本本记录上递归函数是在一个函数通过名字调用自身的情况下构成1234567function recursion(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * recursion(num - 1); &#125;&#125; 123var anotherRecursion = recursion;recursion = null;anotherRecursion(4) //出错 以上代码先把recursion()函数保存在变量anotherRecursion中，然后将recursion变量设置为null，结果指向原始函数的引用只有一个了，但在接下来的调用由于必须调用recursion，而recursion已经不是函数了所以会导致错误。在看了相关文档发现使用arguments.callee可以解决这个问题。1234567function recursion(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num - 1); &#125;&#125; 注：arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。在后面也发现一个bug，在严格模式下这样写是不适应的会报错。在最后用命名函数解决了这些问题。1234567var recursion = (function r(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * r(num - 1); &#125;&#125;); 记录下来，更多有助于自己去总结和技术提升之后的优化代码","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"小程序ios输入表情显示和存取问题","slug":"小程序中ios手机输入法带有表情显示问题","date":"2018-11-29T11:25:39.000Z","updated":"2019-02-11T04:03:58.226Z","comments":true,"path":"2018/11/29/小程序中ios手机输入法带有表情显示问题/","link":"","permalink":"http://yoursite.com/2018/11/29/小程序中ios手机输入法带有表情显示问题/","excerpt":"小程序输入表情处理项目中有个一个评论的功能，很平常的一个功能但是在安卓机上没有任何问题，却在ios上面输入评论的时候却有一个可以输入表情的按钮这个是在安卓上没有就有点尴尬了也是微信上独有的。找了一个其他小程序的输入也有这个功能都可以使用就觉得这个就不是问题了想了半天试过base64的方式但转换回来的时候就不正确了。最后使用了二进制的方式发送给后台。","text":"小程序输入表情处理项目中有个一个评论的功能，很平常的一个功能但是在安卓机上没有任何问题，却在ios上面输入评论的时候却有一个可以输入表情的按钮这个是在安卓上没有就有点尴尬了也是微信上独有的。找了一个其他小程序的输入也有这个功能都可以使用就觉得这个就不是问题了想了半天试过base64的方式但转换回来的时候就不正确了。最后使用了二进制的方式发送给后台。 JavaScript函数1234567891011121314151617181920212223242526//将字符串转换成二进制形式，中间用空格隔开const strToBinary = (str) =&gt; &#123; let result = []; let list = str.split(&apos;&apos;); for(let i = 0;i&lt;list.length;i++)&#123; if(i != 0)&#123; result.push(&apos; &apos;); &#125; let item = list[i]; let binartStr = item.charCodeAt().toString(2); result.push(binartStr); &#125; return result.join(&apos;&apos;);&#125;//将二进制字符串转换成Unicode字符串const binaryToStr = (str) =&gt; &#123; let result = []; let list = str.split(&apos; &apos;); for(let i=0;i&lt;list.length;i++)&#123; let item = list[i]; let asciiCode = parseInt(item,2); let charValue = String.fromCharCode(asciiCode); result.push(charValue); &#125; return result.join(&apos;&apos;);&#125; 此Demo为在工作中所遇到的需求 记录下来，更多有助于自己去总结和技术提升之后的优化代码","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/组件/"}]},{"title":"小程序富文本显示","slug":"小程序富文本显示","date":"2018-11-29T11:25:39.000Z","updated":"2019-02-11T03:38:05.785Z","comments":true,"path":"2018/11/29/小程序富文本显示/","link":"","permalink":"http://yoursite.com/2018/11/29/小程序富文本显示/","excerpt":"JS - 实现HTML标签的转义在小程序中的富文本编辑后的文本显示，小程序文档中有提供组件，我这里后台用的是百度的UEditor编辑器所在数据库中存有‘lt’，‘gt’等字符是在rich-text中处理不了的。通过想到转义的方法就到网上去找了一些相关的博客了解了一下根据别人的办法改变一下变成自己的解决办法。使用以下封装函数进行处理后在用rich-text组件即可达到正确显示的效果，通过正则表达式进行替换","text":"JS - 实现HTML标签的转义在小程序中的富文本编辑后的文本显示，小程序文档中有提供组件，我这里后台用的是百度的UEditor编辑器所在数据库中存有‘lt’，‘gt’等字符是在rich-text中处理不了的。通过想到转义的方法就到网上去找了一些相关的博客了解了一下根据别人的办法改变一下变成自己的解决办法。使用以下封装函数进行处理后在用rich-text组件即可达到正确显示的效果，通过正则表达式进行替换 JavaScript函数123456789101112131415//HTML标签转义（&lt; -&gt; &amp;lt;）//html2Escape函数是让其转换成标签形式,这里我们不需要这种function html2Escape(sHtml) &#123; return sHtml.replace(/[&lt;&gt;&amp;&quot;]/g,function(c)&#123; return &#123;&apos;&lt;&apos;:&apos;&amp;lt;&apos;,&apos;&gt;&apos;:&apos;&amp;gt;&apos;,&apos;&amp;&apos;:&apos;&amp;amp;&apos;,&apos;&quot;&apos;:&apos;&amp;quot;&apos;&#125;[c]; &#125;);&#125;//HTML标签反转义（&amp;lt; -&gt; &lt;）//escape2Html是让内容中存在的&amp;lt标签转换成html标签，使用这种就可以解决const escape2Html = (str) =&gt; &#123; let arrEntities = &#123;&apos;lt&apos;:&apos;&lt;&apos;,&apos;gt&apos;:&apos;&gt;&apos;,&apos;nbsp&apos;:&apos; &apos;,&apos;amp&apos;:&apos;&amp;&apos;,&apos;quot&apos;:&apos;&quot;&apos;&#125;; return str.replace(/&amp;(lt|gt|nbsp|amp|quot);/ig,function(all,t)&#123; return arrEntities[t]; &#125;);&#125; 此Demo为在工作中所遇到的需求 记录下来，更多有助于自己去总结和技术提升之后的优化代码","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/组件/"}]},{"title":"vue表情emoji组件","slug":"vue表情emoji组件","date":"2018-11-21T14:48:25.000Z","updated":"2019-02-11T03:13:58.219Z","comments":true,"path":"2018/11/21/vue表情emoji组件/","link":"","permalink":"http://yoursite.com/2018/11/21/vue表情emoji组件/","excerpt":"emoji表情Demo直接上代码","text":"emoji表情Demo直接上代码 index.js1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot; id=&quot;app&quot;&gt; &lt;p&gt;文本输入框&lt;/p&gt; &lt;textarea class=&quot;text&quot; rows=&quot;5&quot; v-model=&quot;content&quot; &gt;&lt;/textarea&gt; &lt;p&gt;表情选择框&lt;/p&gt; &lt;v-emotion @emotion=&quot;handleEmotion&quot; :height=&quot;200&quot; &gt;&lt;/v-emotion&gt; &lt;p&gt;效果显示框&lt;/p&gt; &lt;div class=&quot;text-place&quot;&gt; &lt;!-- /\\#[\\u4E00-\\u9FA5]&#123;1,3&#125;\\;/gi 匹配出含 #XXX; 的字段 --&gt; &lt;p v-html=&quot;content.replace(/\\#[\\u4E00-\\u9FA5]&#123;1,3&#125;\\;/gi, emotion)&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.17/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;v-emotion.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;emotion.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; index.js123456789101112131415161718192021window.onload = function()&#123; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; content: &apos;&apos;, comment: &apos;&apos;, &#125;, methods:&#123; handleEmotion (i) &#123; this.content += i; &#125;, // 将匹配结果替换表情图片 emotion (res) &#123; let word = res.replace(/\\#|\\;/gi,&apos;&apos;); const list = [&apos;微笑&apos;, &apos;撇嘴&apos;, &apos;色&apos;, &apos;发呆&apos;, &apos;得意&apos;, &apos;流泪&apos;, &apos;害羞&apos;, &apos;闭嘴&apos;, &apos;睡&apos;, &apos;大哭&apos;, &apos;尴尬&apos;, &apos;发怒&apos;, &apos;调皮&apos;, &apos;呲牙&apos;, &apos;惊讶&apos;, &apos;难过&apos;, &apos;酷&apos;, &apos;冷汗&apos;, &apos;抓狂&apos;, &apos;吐&apos;, &apos;偷笑&apos;, &apos;可爱&apos;, &apos;白眼&apos;, &apos;傲慢&apos;, &apos;饥饿&apos;, &apos;困&apos;, &apos;惊恐&apos;, &apos;流汗&apos;, &apos;憨笑&apos;, &apos;大兵&apos;, &apos;奋斗&apos;, &apos;咒骂&apos;, &apos;疑问&apos;, &apos;嘘&apos;, &apos;晕&apos;, &apos;折磨&apos;, &apos;衰&apos;, &apos;骷髅&apos;, &apos;敲打&apos;, &apos;再见&apos;, &apos;擦汗&apos;, &apos;抠鼻&apos;, &apos;鼓掌&apos;, &apos;糗大了&apos;, &apos;坏笑&apos;, &apos;左哼哼&apos;, &apos;右哼哼&apos;, &apos;哈欠&apos;, &apos;鄙视&apos;, &apos;委屈&apos;, &apos;快哭了&apos;, &apos;阴险&apos;, &apos;亲亲&apos;, &apos;吓&apos;, &apos;可怜&apos;, &apos;菜刀&apos;, &apos;西瓜&apos;, &apos;啤酒&apos;, &apos;篮球&apos;, &apos;乒乓&apos;, &apos;咖啡&apos;, &apos;饭&apos;, &apos;猪头&apos;, &apos;玫瑰&apos;, &apos;凋谢&apos;, &apos;示爱&apos;, &apos;爱心&apos;, &apos;心碎&apos;, &apos;蛋糕&apos;, &apos;闪电&apos;, &apos;炸弹&apos;, &apos;刀&apos;, &apos;足球&apos;, &apos;瓢虫&apos;, &apos;便便&apos;, &apos;月亮&apos;, &apos;太阳&apos;, &apos;礼物&apos;, &apos;拥抱&apos;, &apos;强&apos;, &apos;弱&apos;, &apos;握手&apos;, &apos;胜利&apos;, &apos;抱拳&apos;, &apos;勾引&apos;, &apos;拳头&apos;, &apos;差劲&apos;, &apos;爱你&apos;, &apos;NO&apos;, &apos;OK&apos;, &apos;爱情&apos;, &apos;飞吻&apos;, &apos;跳跳&apos;, &apos;发抖&apos;, &apos;怄火&apos;, &apos;转圈&apos;, &apos;磕头&apos;, &apos;回头&apos;, &apos;跳绳&apos;, &apos;挥手&apos;, &apos;激动&apos;, &apos;街舞&apos;, &apos;献吻&apos;, &apos;左太极&apos;, &apos;右太极&apos;]; let index = list.indexOf(word); return `&lt;img src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/$&#123;index&#125;.gif&quot; align=&quot;middle&quot;&gt;`; &#125; &#125;, &#125;);&#125; index.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.container &#123; margin: 0 auto; margin-top: 20px; width: 400px; &#125; .text &#123; display: block; margin: 0 auto; margin-bottom: 10px; width: 400px; resize: none; box-sizing: border-box; padding: 5px 10px; border-radius: 8px; &#125; .text-place &#123; height: 80px; box-sizing: border-box; padding: 5px 10px; border-radius: 8px; background: #ddd5d5; &#125; .text-place p &#123; display: flex; align-items: center; margin: 0; &#125; .emotion-box &#123; margin: 0 auto; width: 100%; box-sizing: border-box; padding: 5px; border: 1px solid #b4b4b4; overflow: hidden; overflow-y: auto; &#125; .emotion-box-line &#123; display: flex; &#125; .emotion-item &#123; flex: 1; text-align: center; cursor: pointer; &#125; .ly-emotion &#123; display: inline-block &#125; .ly-static-emotion &#123; width: 24px; height: 24px; display: inline-block; &#125; v-emotion.js12345678910111213141516171819202122232425262728293031323334353637Vue.component(&apos;v-emotion&apos;,&#123; data: function () &#123; return &#123; list: [ [&apos;微笑&apos;, &apos;撇嘴&apos;, &apos;色&apos;, &apos;发呆&apos;, &apos;得意&apos;, &apos;流泪&apos;, &apos;害羞&apos;, &apos;闭嘴&apos;], [&apos;睡&apos;, &apos;大哭&apos;, &apos;尴尬&apos;, &apos;发怒&apos;, &apos;调皮&apos;, &apos;呲牙&apos;, &apos;惊讶&apos;, &apos;难过&apos;] [&apos;酷&apos;, &apos;冷汗&apos;, &apos;抓狂&apos;, &apos;吐&apos;, &apos;偷笑&apos;, &apos;可爱&apos;, &apos;白眼&apos;, &apos;傲慢&apos;], [&apos;饥饿&apos;, &apos;困&apos;, &apos;惊恐&apos;, &apos;流汗&apos;, &apos;憨笑&apos;, &apos;大兵&apos;, &apos;奋斗&apos;, &apos;咒骂&apos;], [&apos;疑问&apos;, &apos;嘘&apos;, &apos;晕&apos;, &apos;折磨&apos;, &apos;衰&apos;, &apos;骷髅&apos;, &apos;敲打&apos;, &apos;再见&apos;], [&apos;擦汗&apos;, &apos;抠鼻&apos;, &apos;鼓掌&apos;, &apos;糗大了&apos;, &apos;坏笑&apos;, &apos;左哼哼&apos;, &apos;右哼哼&apos;, &apos;哈欠&apos;], [&apos;鄙视&apos;, &apos;委屈&apos;, &apos;快哭了&apos;, &apos;阴险&apos;, &apos;亲亲&apos;, &apos;吓&apos;, &apos;可怜&apos;, &apos;菜刀&apos;], [&apos;西瓜&apos;, &apos;啤酒&apos;, &apos;篮球&apos;, &apos;乒乓&apos;, &apos;咖啡&apos;, &apos;饭&apos;, &apos;猪头&apos;, &apos;玫瑰&apos;,], [&apos;凋谢&apos;, &apos;示爱&apos;, &apos;爱心&apos;, &apos;心碎&apos;, &apos;蛋糕&apos;, &apos;闪电&apos;, &apos;炸弹&apos;, &apos;刀&apos;], [&apos;足球&apos;, &apos;瓢虫&apos;, &apos;便便&apos;, &apos;月亮&apos;, &apos;太阳&apos;, &apos;礼物&apos;, &apos;拥抱&apos;, &apos;强&apos;], [&apos;弱&apos;, &apos;握手&apos;, &apos;胜利&apos;, &apos;抱拳&apos;, &apos;勾引&apos;, &apos;拳头&apos;, &apos;差劲&apos;, &apos;爱你&apos;], [&apos;NO&apos;, &apos;OK&apos;, &apos;爱情&apos;, &apos;飞吻&apos;, &apos;跳跳&apos;, &apos;发抖&apos;, &apos;怄火&apos;, &apos;转圈&apos;], [&apos;磕头&apos;, &apos;回头&apos;, &apos;跳绳&apos;, &apos;挥手&apos;, &apos;激动&apos;, &apos;街舞&apos;, &apos;左太极&apos;, &apos;右太极&apos;], ] &#125; &#125;, template: `&lt;div&gt;&lt;div class=&quot;emotion-box&quot; :style=&quot;&#123;height: height + &apos;px&apos; &#125;&quot;&gt; &lt;div class=&quot;emotion-box-line&quot; v-for=&quot;(line, i) in list&quot; :key=&quot;i&quot; &gt; &lt;emotion class=&quot;emotion-item&quot; v-for=&quot;(item, i) in line&quot; :key=&quot;i&quot; @click.native=&quot;clickHandler(item)&quot; &gt;&#123;&#123;item&#125;&#125;&lt;/emotion&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;`, props: &#123; height: &#123; type: Number, default: 200, &#125; &#125;, methods: &#123; clickHandler (i) &#123; let emotion = `#$&#123;i&#125;;` this.$emit(&apos;emotion&apos;, emotion) &#125; &#125;,&#125;); emotion.js1234567891011121314151617Vue.component(&apos;emotion&apos;,&#123; data: function () &#123; return &#123;&#125; &#125;, template: `&lt;div class=&quot;ly-emotion&quot; &gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`, name: &apos;ly-emotion&apos;, mounted () &#123; const name = this.$el.innerHTML; console.log(name); const list = [&apos;微笑&apos;, &apos;撇嘴&apos;, &apos;色&apos;, &apos;发呆&apos;, &apos;得意&apos;, &apos;流泪&apos;, &apos;害羞&apos;, &apos;闭嘴&apos;, &apos;睡&apos;, &apos;大哭&apos;, &apos;尴尬&apos;, &apos;发怒&apos;, &apos;调皮&apos;, &apos;呲牙&apos;, &apos;惊讶&apos;, &apos;难过&apos;, &apos;酷&apos;, &apos;冷汗&apos;, &apos;抓狂&apos;, &apos;吐&apos;, &apos;偷笑&apos;, &apos;可爱&apos;, &apos;白眼&apos;, &apos;傲慢&apos;, &apos;饥饿&apos;, &apos;困&apos;, &apos;惊恐&apos;, &apos;流汗&apos;, &apos;憨笑&apos;, &apos;大兵&apos;, &apos;奋斗&apos;, &apos;咒骂&apos;, &apos;疑问&apos;, &apos;嘘&apos;, &apos;晕&apos;, &apos;折磨&apos;, &apos;衰&apos;, &apos;骷髅&apos;, &apos;敲打&apos;, &apos;再见&apos;, &apos;擦汗&apos;, &apos;抠鼻&apos;, &apos;鼓掌&apos;, &apos;糗大了&apos;, &apos;坏笑&apos;, &apos;左哼哼&apos;, &apos;右哼哼&apos;, &apos;哈欠&apos;, &apos;鄙视&apos;, &apos;委屈&apos;, &apos;快哭了&apos;, &apos;阴险&apos;, &apos;亲亲&apos;, &apos;吓&apos;, &apos;可怜&apos;, &apos;菜刀&apos;, &apos;西瓜&apos;, &apos;啤酒&apos;, &apos;篮球&apos;, &apos;乒乓&apos;, &apos;咖啡&apos;, &apos;饭&apos;, &apos;猪头&apos;, &apos;玫瑰&apos;, &apos;凋谢&apos;, &apos;示爱&apos;, &apos;爱心&apos;, &apos;心碎&apos;, &apos;蛋糕&apos;, &apos;闪电&apos;, &apos;炸弹&apos;, &apos;刀&apos;, &apos;足球&apos;, &apos;瓢虫&apos;, &apos;便便&apos;, &apos;月亮&apos;, &apos;太阳&apos;, &apos;礼物&apos;, &apos;拥抱&apos;, &apos;强&apos;, &apos;弱&apos;, &apos;握手&apos;, &apos;胜利&apos;, &apos;抱拳&apos;, &apos;勾引&apos;, &apos;拳头&apos;, &apos;差劲&apos;, &apos;爱你&apos;, &apos;NO&apos;, &apos;OK&apos;, &apos;爱情&apos;, &apos;飞吻&apos;, &apos;跳跳&apos;, &apos;发抖&apos;, &apos;怄火&apos;, &apos;转圈&apos;, &apos;磕头&apos;, &apos;回头&apos;, &apos;跳绳&apos;, &apos;挥手&apos;, &apos;激动&apos;, &apos;街舞&apos;, &apos;献吻&apos;, &apos;左太极&apos;, &apos;右太极&apos;]; let index = list.indexOf(name); let imgHTML = `&lt;img src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/$&#123;index&#125;.gif&quot;&gt;`; this.$nextTick(() =&gt; &#123; this.$el.innerHTML = imgHTML; &#125;) &#125;,&#125;) 此Demo为在工作中所遇到的需求 记录下来，更多有助于自己去总结和技术提升之后的优化代码","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/组件/"}]},{"title":"关于前端跨域解决方法","slug":"关于前端跨域解决方法","date":"2018-11-12T02:11:16.000Z","updated":"2018-11-12T03:26:28.722Z","comments":true,"path":"2018/11/12/关于前端跨域解决方法/","link":"","permalink":"http://yoursite.com/2018/11/12/关于前端跨域解决方法/","excerpt":"跨域 网络协议不同(http/https) 域名不同(www.baidu.com/www.baidu.cn) 端口不一样 以上三个都一样时称“同源策略”，否则就是跨域请求","text":"跨域 网络协议不同(http/https) 域名不同(www.baidu.com/www.baidu.cn) 端口不一样 以上三个都一样时称“同源策略”，否则就是跨域请求 在前端HTML中的部分标签是自带跨域天赋 a连接、重定向、Form表单提交 资源引入：&lt;link&gt; 、 &lt;script&gt; 、 &lt;img&gt;等…css里面的 background-image 、 @font-face()在img中第三方的服务端会有防盗链使获取不到图片 跨域解决ajax-JSONP1234567$.ajax(&#123; url: &apos;http://www.baidu.com:8080/action&apos;, type: &apos;get&apos;, dataType: &apos;jsonp&apos;, // 请求方式为jsonp jsonpCallback: &quot;collback&quot;, // 自定义回调函数名 data: &#123;&#125;&#125;); proxyTable代理(node)这个代理实际上是用的node的http-proxy-middleware插件完成跨域请求代理跨域本质 本地服务器 –》 代理 –》目标服务器 –》拿到数据后通过代理伪装成本地服务请求的返回值 —》然后浏览器就顺利收到了我们想要的数据以上是两种是我常用的、以下是前端的各种跨域解决方式 1、通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"}]},{"title":"记一个音乐播放器进度条组件-Vue","slug":"记一个音乐播放器进度条组件-Vue","date":"2018-11-02T13:21:13.000Z","updated":"2018-11-03T08:02:26.000Z","comments":true,"path":"2018/11/02/记一个音乐播放器进度条组件-Vue/","link":"","permalink":"http://yoursite.com/2018/11/02/记一个音乐播放器进度条组件-Vue/","excerpt":"音乐播放器之进度条 HTML代码部分 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; v-cloak&gt; &lt;audio src=&quot;http://up.mcyt.net/?down/46426.mp3&quot; ref=&quot;player&quot;&gt;&lt;/audio&gt; &lt;p&gt;已播放时间:&#123;&#123;cTime&#125;&#125;&lt;/p&gt; &lt;p&gt;总时间:&#123;&#123;dTime&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;audioState&quot;&gt;&#123;&#123;status&#125;&#125;&lt;/button&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div class=&quot;progressbar&quot; ref=&quot;runfatbar&quot; @click=&quot;playMusic&quot;&gt; &lt;div class=&quot;greenbar&quot; ref=&quot;runbar&quot;&gt; &lt;span class=&quot;yuan&quot; draggable=&quot;true&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.17/vue.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","text":"音乐播放器之进度条 HTML代码部分 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; v-cloak&gt; &lt;audio src=&quot;http://up.mcyt.net/?down/46426.mp3&quot; ref=&quot;player&quot;&gt;&lt;/audio&gt; &lt;p&gt;已播放时间:&#123;&#123;cTime&#125;&#125;&lt;/p&gt; &lt;p&gt;总时间:&#123;&#123;dTime&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;audioState&quot;&gt;&#123;&#123;status&#125;&#125;&lt;/button&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div class=&quot;progressbar&quot; ref=&quot;runfatbar&quot; @click=&quot;playMusic&quot;&gt; &lt;div class=&quot;greenbar&quot; ref=&quot;runbar&quot;&gt; &lt;span class=&quot;yuan&quot; draggable=&quot;true&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.17/vue.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript代码部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293window.onload = function()&#123; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; cTime:&apos;00:00&apos;, dTime:&apos;00:00&apos;, play:false, status:&apos;暂停&apos; &#125;, mounted()&#123; const music = this.$refs.player; // 音频所在对象 const musicBar = this.$refs.runbar; // 颜色进度条所在对象 const musicWidth = this.$refs.runfatbar.offsetWidth; // 底部进度条总宽 // 初始化音频信息 music.addEventListener(&apos;canplay&apos;, () =&gt; &#123; const musicTime = music.duration; // 获得音频时长 const branch = Math.floor(musicTime / 60); // 计算音频分钟 const second = Math.ceil(musicTime % 60); // 计算音频秒 if(branch &lt; 10 &amp;&amp; second &lt; 10)&#123; // 四种情况判断音频总时间 this.dTime = `0$&#123;branch&#125;:0$&#123;second&#125;`; &#125;else if(branch &lt; 10)&#123; this.dTime = `0$&#123;branch&#125;:$&#123;second&#125;`; &#125;else if(second &lt; 10)&#123; this.dTime = `$&#123;branch&#125;:0$&#123;second&#125;`; &#125;else&#123; this.dTime = `$&#123;branch&#125;:$&#123;second&#125;`; &#125; &#125;) // 音频正在播放 music.addEventListener(&apos;timeupdate&apos;,() =&gt; &#123; const musicTime = music.duration; // 获得音频时长 const stopTime = music.currentTime // 获得已播放的音频时长 musicBar.style.width = `$&#123;(stopTime / musicTime) * 100&#125;%`; // 计算进度条所在比例宽度 const branch = Math.floor(stopTime / 60); // 计算已播放的音频分钟 const second = Math.floor(stopTime % 60); // 计算已播放的音频秒 if (branch &lt; 10 &amp;&amp; second &lt; 10) &#123; // 四种情况判断显示音频以播放时间 this.cTime = `0$&#123;branch&#125;:0$&#123;second&#125;`; &#125; else if (branch &lt; 10) &#123; this.cTime = `0$&#123;branch&#125;:$&#123;second&#125;`; &#125; else if (second &lt; 10) &#123; this.cTime = `$&#123;branch&#125;:0$&#123;second&#125;`; &#125; else &#123; this.cTime = `$&#123;branch&#125;:$&#123;second&#125;`; &#125; &#125;) // 移动端监听进度条触摸拖动 musicBar.addEventListener(&apos;touchmove&apos;,(event) =&gt; &#123; const events = event.targetTouches[0].pageX; // 获得触摸拖动的距离 musicBar.style.width = `$&#123;(events / musicWidth) * 100&#125;%`; // 计算进度条所在比例宽度 music.pause(); // 触摸拖动时停止播放 &#125;) // 移动端监听进度条触摸拖动结束 musicBar.addEventListener(&apos;touchend&apos;,() =&gt; &#123; const touwidth = (musicBar.offsetWidth / musicWidth); // 计算进度条所在比例 music.currentTime = music.duration * touwidth; // 通过所在比例赋值给音频应在的播放时间 music.play(); // 根据播放时间开始播放 this.play = true // 更改播放暂停按钮为播放 &#125;) &#125;, methods:&#123; // 播放暂停 audioState()&#123; this.play = !this.play; const music = this.$refs.player; if(this.play)&#123; music.play(); this.status = &apos;播放&apos;; console.log(&apos;开始播放&apos;); &#125;else&#123; music.pause(); this.status = &apos;暂停&apos;; console.log(&apos;暂停播放&apos;); &#125; &#125;, // 点击进度条事件 playMusic(e)&#123; const music = this.$refs.player; // 音频所在对象 const barWidth = e.pageX / this.$refs.runfatbar.offsetWidth; // 计算点击位置相对父元素总宽的比例 this.$refs.runbar.style.width = `$&#123;barWidth * 100&#125;%`; // 进度条应所在的比例总宽 music.currentTime = music.duration * barWidth; // 计算点击时应播放所在的时间 music.play(); // 播放音频 this.play = true; // 更改播放暂停按钮为播放 &#125; &#125; &#125;)&#125; Css部分 12345678910111213141516171819202122232425262728293031[v-cloak]&#123; display: none !important; &#125; .bar&#123; width:100%; height:30px; line-height:30px; &#125; .bar .progressbar&#123; width: 100%; height:10px; background-color: #999999; margin-top:10px; border-radius:30px; position: relative; &#125; .bar .greenbar &#123; width: 0%; height:10px; border-radius:30px; position: absolute; top: 0; left: 0; background-color: #1296db; &#125; .bar .greenbar .yuan&#123; display: inline-block; background-color: #ffffff; border-radius: 50%; position: absolute; &#125; $refs，ref ref简单理解就好比一个标签的id属性 12&lt;p id=&quot;testId&quot;&gt;这里是一个p标签&lt;/p&gt;&lt;p ref=&quot;testId&quot;&gt;这里是一个p标签&lt;/p&gt; this.$refs.testId.value与document.getelementbyid(“testId”).value 获取的都是一样的结果在Vue中使用$refs去操作节点会减少对于Dom的操作 v-cloak 在页面加载未完成显示白屏避免显示出Vue变量名","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"第一篇博客","slug":"Hello-Node","date":"2018-10-25T07:36:14.000Z","updated":"2018-11-03T08:06:12.000Z","comments":true,"path":"2018/10/25/Hello-Node/","link":"","permalink":"http://yoursite.com/2018/10/25/Hello-Node/","excerpt":"Hello Node12345678910var http = require(&apos;http&apos;);const server = http.createServer(req,res =&gt; &#123; res.end(&apos;Hello Node\\n&apos;);&#125;);server.listen(8888);// 终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);","text":"Hello Node12345678910var http = require(&apos;http&apos;);const server = http.createServer(req,res =&gt; &#123; res.end(&apos;Hello Node\\n&apos;);&#125;);server.listen(8888);// 终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]}]}